
for jjjj = [19 21 22 23 24 25 26 29 30 31 32 33 36 37]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%This script reads a .raw B scan file generated by the Telesto and
%processes it to give a two-dimensional scan.  The .raw files are generated
%automatically by the OCT software.
%
%Images are currently fixed at 1 mm wide in the SDK program.
%
%Images are 10000 pixels by 1024 pixels.  z resolution is 2.7 micron/pixel
%and is fixed by the objective on the Telesto.  x "resolution" is
%width/pixels and will vary based on the image size. To change the image
%resolution or width, make the changes in the C++ source code and recompile
%the SDK program.
%
%Experimented with 2 mm wide scans (which have a lot of wasted space).
%
%Goal is to have structural images taken automatically before each run.

warning off;

%Total Number of Shots = filesize (in BYTES!!!!) /(2 * 2048)

%                      = filesize (in kB) / 4

%There are 2048 photodetectors in the line camera and each pixel holds 2
%Bytes of image depth.  On a Windows machine, 1 kB == 1024 Bytes.

num_bkg = 177;
%Depth pixels in z
col = 2048;
numApos = num_bkg;

%Import OCT parameters
Offset = double(importdata('D:\Thorlabs Matlab Files\OCT Calibration Files\Offset.dat'));
Chirp=importdata('D:\Thorlabs Matlab Files\OCT Calibration Files\Chirp.dat');
electronScaling = 540;

%Matrix for interpolation from lambda to k-domain.  In the future, the matrix
%could be stored and just called.
Mdc = zeros(2048,2048);
for m = 1:2048
    
    basevec = zeros(2048,1);
    basevec(m) = 1;
    Mdc(:,m) = lamb2k_v3(basevec, Chirp);
    
end


tic;

%run_num = input('Enter the run number: ');
%inputfile = ['Bscan_e1r', num2str(run_num), '.raw'];
inputfile = ['D:\Fully Processed\Bscan_e1r',int2str(jjjj),'.raw'];

fin = fopen(inputfile,'r'); %Open the raw data set
I=fread(fin,'uint16', 'l');            %Read the raw data
fclose(fin);                           %// Close the file
row_raw = length(I)./2048;
row = row_raw - num_bkg;
outputraw = reshape(I(1:end), [2048 row_raw]);   % column = 2048, row_raw=104880+320

clear I;

outputraw = outputraw*electronScaling;
%     for i = 1:row_raw
%         outputraw(:,i) = outputraw(:,i) - Offset;
%     end

%Spectrum = mean(outputraw(:,1:num_bkg), 2);
Spectrum = mean(outputraw(:,77:77+25),2);
RawData_total = outputraw(:,num_bkg+1:end);

clear outputraw;

%Replicate the background A-scan into a full background the size of the raw data
Background = repmat(Spectrum, [1 row]);
minbackground = min(Background);
maxbackground = max(Background);

norm_background = zeros(1,col);
for i=1:col
    norm_background(i)=(Background(i)-minbackground) / (maxbackground-minbackground);
end

clear minbackground maxbackground;

%Set up the length of the apodization window
%Fit the source spectrum (contained in the background scan) with a
%polynomial fit.
%Normalize the polynomial fit of the source spectrum
z_axis=1:col;
p = polyfit(z_axis', norm_background',9);
norm_background_smooth = polyval(p, z_axis');

hann_win=hann(col);
%hann_win=flattopwin(col);
w = hann_win./norm_background_smooth;
DC_subtracted=RawData_total-Background;

%Used for testing different windows.  Commented out.
%{
    figure;
    plot(w,'r');
    hold on;
    plot(hann_win,'b');
    
    hold off;
    ylabel('Amplitude');
    xlabel('Lambda Domain');
    
%}

clear Background;
clear norm_background norm_background_smooth;
clear RawData_total;

Apod = zeros(col,row);
for i=1:row
    Apod(:,i) = w.*DC_subtracted(:,i);
end

clear w;
clear DC_subtracted;
clear offset Spectrum z_axis;


%Transform from lambda to k-domain.
%This is Marcel's method for interpolation using matrix multiplcation.
data= Mdc * Apod;
disp('OK to generating data');

Bscantest=20*log10(abs(fft(data)));
%Try without using deChrip.  (No lambda- to k-domain interpolation.)
%Bscantest=20*log10(abs(fft(Apod)));
[bscanx bscany] = size(Bscantest);
Bscantest(1025:2048,:)=[];

%Use a Gaussian filter to eliminate the salt and pepper noise in the
%lower half of the image.  This improves the image quailty, but please
%note that we do not use a filter when we take the time-locked A-scans.


outputfilename = inputfile(1:end-4);

Bscantest = imgaussfilt(Bscantest,2);
BScan = Bscantest(1:512,4000:8000);

figure;
imagesc(BScan)
colormap('gray')
line([999,999],[1,512],'Color','white')

save(outputfilename,'BScan');

clear
end
% 
% %imagesc(Bscantest);
% %colormap gray;
% %box off;
% 
% %Set aspect ratio so the image looks right.
% %Note that 2.7 microns per pixel in the axial direction is based on the
% %refractive index (n = 1.33 in water).  If the Telsto is imaging in air
% %the scale (microns per pixel) will be different.
% pbaspect([1 2.7 1])
% title(inputfile(1:end-4), 'Interpreter','None');
% %grid on;
% set(gca, 'GridColor',[1,1,1]);
% set(gca, 'GridLineStyle', '-');
% set(gca, 'GridAlpha', .5);
% %xlim([3500 6500])
% %ylim([250 400])]
% outputfilename = [inputfile(1:end-4), '.png'];
% %print(outputfilename,'-dpng')
% 
% %     Save without using Chirp if you want.  Just used for comparrison.
% %     outputfilename = [inputfile(1:end-4), 'NoChirp.tif'];
% %     print(outputfilename,'-dpng')
% %     print(outputfilename, '-dtiff');
% 
% clear data;
% 
% elapsed = toc;
% disp(['It took ', num2str(elapsed), ' seconds.']);
% 
% % clear inputfile filelist Offset num* p row row_* Chirp bscanx bscany hann_win;
% % clear i ii j electronScaling fin elapsed pts sampfreq w;
% % clear Bscantest outputfilename dims;
% 
% 
